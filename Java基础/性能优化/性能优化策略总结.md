## 代码
性能优化应该做的第一步就是对相关代码的分析，定位到性能瓶颈，很多时候性能问题就是因为代码的不合理所导致的，同时随着技术的发展，有可能出现了新的效率更高的方式可以替换原代码。比如说for循环在java8中使用foreach+lambda表达式(jvm预热的情况下)替换原来的fori以及for(:)不仅在代码书写上更直观，而且在性能上也有了优化。

## 数据库
在现实场景中，业务上的性能优化的瓶颈往往都和数据库有关。数据库的调优可以分为三个方面：SQL优化，连接池优化，架构上优化。

### SQL优化
SQL调优的步骤大概是（以mysql为例）: 通过慢查询日志定位到sql，然后通过explain，profile等数据库诊断工具分析sql，优化sql后进行测试比较。

### 连接池优化

### 架构优化

## 缓存
从数据库中读取写入数据是需要经过磁盘的IO，而这是一个本身就很耗时的操作，因此使用缓存来进行一些热点数据的处理可以提升性能。缓存可以分为两类：
* 本地缓存：比如说map，Guava中的cache等
* 分布式缓存：比如说redis，memcache。

一般的应用系统，读写比例大概在10:1左右，因此对读取使用缓存可以提升性能，但是这里需要考虑的一个问题是什么时候更新缓存？
如果先删除缓存，再更新数据库，然后通过后续操作来装载缓存，这样是有问题的。比如两个线程一个读，一个写，当写的线程先删除了缓存但还没更新数据库，此时读线程因为没有命中缓存而直接读取数据库，就得到了脏数据，并且把脏数据又加载到了缓存中。

可以采取的方式是先更新数据库，然后再失效对应的缓存，然后通过后续操作来装载缓存。首先这样还是会出现并发的问题，比如当更新了数据库但还没有失效缓存，此时并发的读线程读到的还是原来的数据，但是不会出现上面那种一直读取到脏数据的问题。当然还有可能出现读线程没有命中缓存，去数据库中读取数据，还没有更新缓存的时候此时写线程更新了数据库，然后读线程就把脏数据加载到缓存中了，但是因为写操作远比读操作耗时，所以这种情况出现的概率很小。

## 异步
如果在业务中需要对数据进行计算，但是调用方并不急着需要计算结果的时候，就很适合使用异步了。比如说进行统计的业务往往是从一张表里面查询数据，统计后插入另一张表，前面那张表并不需要等待后面那张表插入成功的结果返回才继续查询，常见的做法是查询得到数据之后，另开一个线程去统计插入，让主线程继续查询得到数据。如果数据量很大的话，可以通过BlockingQueue来进行优化，主线程查询后将数据扔到BlockingQueue，然后异步线程循环批量的从BlockingQueue里面去取数据进行处理。

## JVM调优