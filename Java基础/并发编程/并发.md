## 线程
什么是线程？线程是任务执行的最小单位。在操作系统中，有个概念叫做multitasking(多任务),意思是在同一刻可以运行多个程序。多线程程序在更低的层次拓展了多任务的概念，使得一个程序可以同时执行多个任务，每个任务就是一个线程。操作系统将CPU的时间片分配给每一个线程，从而达到并行处理的效果。

### 线程的状态
* NEW - 线程被创建还没运行的时候的状态
* RUNNABLE - 一旦调用了start方法，线程就进入了RUNNABLE状态，该状态下线程可能在运行也可能没有在运行。可以将其细分为两个状态，**READY**和**RUNNING**。处于就绪态的线程具备了运行所需的条件，只需要在就绪队列里面等待CPU分配时间片就可以进入运行态。常见的操作系统通常采用**抢占式**的调度系统来分配时间片，但是像手机这样的小型设备可以使用协作式调度，此时如果需要从运行态进入就绪态就只能通过yield方法。
* BLOCKED - 当线程尝试获得一个内部的对象锁（而不是java.util.concurrent库中的锁），而该锁被其他线程占有的时候，该线程进入阻塞态。
* WAITING - 当线程等待其他线程通知一个调度器一个条件的时候，该线程进入等待状态。
* TIMED WAITING - 当调用有超时参数的方法的时候会导致线程进入计时等待状态。
* TERMINATED - 终止状态，线程因为执行完毕自然死亡或者因为异常终止意外死亡。

![20190722181611.png](https://repositoryimage.oss-cn-shanghai.aliyuncs.com/img/20190722181611.png)

tips:
- 创建一个线程可以继承Thread类或者实现Runnable接口，Runnable接口是设计来为对于那些处于线程活跃状态的的类定义一种通用的协议。对于程序员来说，继承一个类意味着对该类进行修改或者增强，如果仅仅是为了创建线程使用继承显得不那么合适。

## 阻塞队列
对于多线程程序来说，因为数据是共享的，所以数据的传递往往需要格外谨慎，但通过一个或者多个队列就可以很优雅的解决这个问题。通过队列可以将线程分为生产者线程和消费者线程，生产者线程往队列里添加数据，消费者线程从队列里面获取数据。在Java里，阻塞队列通过接口BlockingQueue来实现。BlockingQueue主要有两种动作，放入和取出，每个动作对应着四种结果，加上返回头元素的两种方法，主要十个方法。

|结果|抛出异常|返回特定值|阻塞|超时|
|---|---|---|---|---|
|加入|add（队列满，抛出IllegalStateException）|offer（队列满返回false）|put（队列满阻塞）|offer(Object, long, TimeUnit)
|取出|remove（队列空，抛出NoSuchElementException）|poll（队列空返回null）|take（队列空阻塞）|poll(long, TimeUnit)
|返回头元素|element（队列空，抛出NoSuchElementException）|peek（队列空返回null）||

tips：

阻塞队列的实现方法都是线程安全的，但是BlockingQueue继承自Queue，而Queue继承自Collection，Collection内部的addAll，removeAll等方法除非继承后有其他实现，默认是非原子操作，是有线程安全问题的。


阻塞队列的实现主要有以下几种：
- ArrayBlockingQueue: A bounded  BlockingQueue  backed by an
  array.  This queue orders elements FIFO . Once created, the capacity cannot be changed. 基于数组实现的阻塞队列，采用先进先出的策略，一旦创建，容量就不能改变了。
- LinkedBlockingQueue：An optionally-bounded BlockingQueue based on linked nodes.This queue orders elements FIFO.The capacity, if unspecified,is equal to Integer.MAX_VALUE.
- DelayQueue: 注入其中的元素必须实现 java.util.concurrent.Delayed 接口,只有那些延迟已经超过时间的元素可以从队列中移出。
- PriorityBlockingQueue : 构造一个无边界阻塞优先队列，用堆实现,无法向这个队列中插入 null 值。所有插入到 PriorityBlockingQueue 的元素必须实现 java.lang.Comparable 接口。因此该队列中元素的排序就取决于你自己的 Comparable 实现。

```java
    /**
    * ArrayBlockingQueue中offer的实现，可以看出
    * 也是通过ReentrantLock来实现的
    */
    public boolean offer(E e) {
        checkNotNull(e);
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            if (count == items.length)
                return false;
            else {
                enqueue(e);
                return true;
            }
        } finally {
            lock.unlock();
        }
    }
```


## Callable和Future
Runnable是一个没有参数，没有返回的异步封装接口，当需要返回值的时候，就可以使用Callable了。Callable接口是一个参数化的类型，只有一个方法call()，返回值类型就是参数的类型。例如Callable<String>就表示将返回一个String类型的值。

通常线程都是通过实现Runnable接口来创建，但是run()方法没有返回，因此如果需要异步计算，并且获取计算的返回结果的时候，显然是不能够的，因此Future就被设计出来了。Future的核心模式就是当异步计算的时候，马上返回一个Future实例，通过这个实例来控制该异步线程，获取执行返回结果。

FutureTask实现了Future和Runnable接口。

```java
    /**
    * 通过callable构建一个既是Future又是Runnable的对象
    */
    public FutureTask(Callable<V> callable) {
        if (callable == null)
            throw new NullPointerException();
        this.callable = callable;
        this.state = NEW;       // ensure visibility of callable
    }
    /**
    * 通过runnable构建一个既是Future又是Runnable的对象
    */
    public FutureTask(Runnable runnable, V result) {
        this.callable = Executors.callable(runnable, result);
        this.state = NEW;       // ensure visibility of callable
    }
```

## Executor框架
创建一个线程是有代价，需要和操作系统进行交互，管理一个线程也是需要牺牲额外的性能的。因此一般不显式的创建线程，而是通过线程池来创建管理线程。Executors工具类有许多静态方法来创建线程池。Executor框架主要包括**Executor**接口，**ExecutorService**接口和**Executors**工具类。

> Executor接口： This interface provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use, scheduling, etc.( 此接口提供了一种将任务提交与每个任务的运行机制分离的方法，包括线程使用，调度等的详细信息。)

> ExecutorService接口： 继承自Executor接口，**submit()**方法提交任务之后会返回一个Future对象，同时提供了关闭线程池的方法，**shutDown()**会在关闭线程池之前执行完当前等待队列中的任务，**shutdownNow()**会取消所有任务并关闭线程。**invokeAny()**和**invokeAll()**会阻塞等待任意一个或者所有的任务执行完。

> Executors是Executor,ExecutorService等的工厂方法。



![20190722183643.png](https://repositoryimage.oss-cn-shanghai.aliyuncs.com/img/20190722183643.png)

tips:

ScheduleExecutorService接口具有预定执行（Scheduled Execution）或者重复执行任务而设计的方法。Executors 类的newScheduledThreadPool 和newSingleThreadScheduledExecutor 方法将返回实现了 ScheduledExecutorService 接口的对象。

## CompletableFuture

### 异步计算
异步调用就是无需等待调用函数的返回结果而可以继续执行操作，异步计算说的是使用另一个线程来完成调用中的计算部分，使调用继续运行或者返回，而不需要等待计算结果。

### 回调函数
通过函数指针调用的函数，吧函数的指针作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数的时候，就说这是会掉函数。回调函数是在特定的事件或者条件发生时由另外一方调用的，用于表示对该事件或者条件进行响应。

定义回调函数 --> 函数实现方初始化后将函数指针传递给调用者 --> 调用者在特定的事件下调用函数

### 与Future的联系
JDK5 新增的Future接口用于描述异步计算的结果，但是对于结果的获取不方便，只能通过阻塞或者轮询的方式得到任务的结果


有结果的同步行为 Callable句柄
无结果的同步行为 Runnable句柄
异步行为         Future句柄
异步回调行为     CompletableFuture句柄


### CompletableFuture的API
- 创建类型：创建CompletableFuture
   1. completedFuture
   2. runAsync
   3. supplyAsync
   4. anyOf
   5. allOf
- 状态相关
   1. join
   2. get
   3. getNow
   4. isCancelled
   5. isCompletedExceptionally
   6. isDone
 - 行为相关
    1. complete
    2. completeExceptionally
    3. cancel
- 回调相关：对计算结果做下一步处理，行为接续
    1. thenApply , thenApplyAsync
    2. thenAccept , thenAcceptAsync
    3. thenRun , thenRunAsync
    4. thenCombine , thenCombineAsync
    5. thenAcceptBoth , thenAcceptBothAsync
    6. runAfterBoth , runAfterBothAsync
    7. applyToEither , applyToEitherAsync
    8. thenCompose , thenComposeAsync
    9. whenComplete , whenCompleteAsync
    10. handle , handleAsync
    11. exceptionally

 规律： 
  * 带Async的是异步方法，不带的则为同步方法
  * 带run的方法，其方法入参的lambda表达式一定是无参数，并且无返回，对应Runnable
  * 带supply的方法，其方法入参的lambda表达式一定是无参数，并且有返回，对应Supplier
  * 带Accept的方法，其方法入参的lambda表达式一定是有参数，并且无返回，对应Consumer
  * 带Apply的方法，其方法入参的lambda表达式一定是有参数，并且有返回，对应Function
  * 

接续即是CompletableFuture存在的核心价值。接续分为以下几种：

CompletableFuture + (Runnable,Consumer,Function)
CompletableFuture + CompletableFuture
CompletableFuture + 结果处理