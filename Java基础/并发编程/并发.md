## 线程
什么是线程？线程是任务执行的最小单位。在操作系统中，有个概念叫做multitasking(多任务),意思是在同一刻可以运行多个程序。多线程程序在更低的层次拓展了多任务的概念，使得一个程序可以同时执行多个任务，每个任务就是一个线程。操作系统将CPU的时间片分配给每一个线程，从而达到并行处理的效果。

### 线程的状态
* NEW - 线程被创建还没运行的时候的状态
* RUNNABLE - 一旦调用了start方法，线程就进入了RUNNABLE状态，该状态下线程可能在运行也可能没有在运行。可以将其细分为两个状态，**READY**和**RUNNING**。处于就绪态的线程具备了运行所需的条件，只需要在就绪队列里面等待CPU分配时间片就可以进入运行态。常见的操作系统通常采用**抢占式**的调度系统来分配时间片，但是像手机这样的小型设备可以使用协作式调度，此时如果需要从运行态进入就绪态就只能通过yield方法。
* BLOCKED - 当线程尝试获得一个内部的对象锁（而不是java.util.concurrent库中的锁），而该锁被其他线程占有的时候，该线程进入阻塞态。
* WAITING - 当线程等待其他线程通知一个调度器一个条件的时候，该线程进入等待状态。
* TIMED WAITING - 当调用有超时参数的方法的时候会导致线程进入计时等待状态。
* TERMINATED - 终止状态，线程因为执行完毕自然死亡或者因为异常终止意外死亡。

![20190722181611.png](https://repositoryimage.oss-cn-shanghai.aliyuncs.com/img/20190722181611.png)

tips:
- 创建一个线程可以继承Thread类或者实现Runnable接口，Runnable接口是设计来为对于那些处于线程活跃状态的的类定义一种通用的协议。对于程序员来说，继承一个类意味着对该类进行修改或者增强，如果仅仅是为了创建线程使用继承显得不那么合适。

## 阻塞队列
对于多线程程序来说，因为数据是共享的，所以数据的传递往往需要格外谨慎，但通过一个或者多个队列就可以很优雅的解决这个问题。通过队列可以将线程分为生产者线程和消费者线程，生产者线程往队列里添加数据，消费者线程从队列里面获取数据。在Java里，阻塞队列通过接口BlockingQueue来实现。BlockingQueue主要有两种动作，放入和取出，每个动作对应着四种结果，加上返回头元素的两种方法，主要十个方法。

|结果|抛出异常|返回特定值|阻塞|超时|
|---|---|---|---|---|
|加入|add（队列满，抛出IllegalStateException）|offer（队列满返回false）|put（队列满阻塞）|offer(Object, long, TimeUnit)
|取出|remove（队列空，抛出NoSuchElementException）|poll（队列空返回null）|take（队列空阻塞）|poll(long, TimeUnit)
|返回头元素|element（队列空，抛出NoSuchElementException）|peek（队列空返回null）||

tips：

阻塞队列的实现方法都是线程安全的，但是BlockingQueue继承自Queue，而Queue继承自Collection，Collection内部的addAll，removeAll等方法除非继承后有其他实现，默认是非原子操作，是有线程安全问题的。


阻塞队列的实现主要有以下几种：
- ArrayBlockingQueue: A bounded  BlockingQueue  backed by an
  array.  This queue orders elements FIFO . Once created, the capacity cannot be changed. 基于数组实现的阻塞队列，采用先进先出的策略，一旦创建，容量就不能改变了。
- LinkedBlockingQueue：An optionally-bounded BlockingQueue based on linked nodes.This queue orders elements FIFO.The capacity, if unspecified,is equal to Integer.MAX_VALUE.
- DelayQueue: 注入其中的元素必须实现 java.util.concurrent.Delayed 接口,只有那些延迟已经超过时间的元素可以从队列中移出。
- PriorityBlockingQueue : 构造一个无边界阻塞优先队列，用堆实现,无法向这个队列中插入 null 值。所有插入到 PriorityBlockingQueue 的元素必须实现 java.lang.Comparable 接口。因此该队列中元素的排序就取决于你自己的 Comparable 实现。

```java
    /**
    * ArrayBlockingQueue中offer的实现，可以看出
    * 也是通过ReentrantLock来实现的
    */
    public boolean offer(E e) {
        checkNotNull(e);
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            if (count == items.length)
                return false;
            else {
                enqueue(e);
                return true;
            }
        } finally {
            lock.unlock();
        }
    }
```


## Callable和Future
Runnable是一个没有参数，没有返回的异步封装接口，当需要返回值的时候，就可以使用Callable了。Callable接口是一个参数化的类型，只有一个方法call()，返回值类型就是参数的类型。例如Callable<String>就表示将返回一个String类型的值。

通常线程都是通过实现Runnable接口来创建，但是run()方法没有返回，因此如果需要异步计算，并且获取计算的返回结果的时候，显然是不能够的，因此Future就被设计出来了。Future的核心模式就是当异步计算的时候，马上返回一个Future实例，通过这个实例来控制该异步线程，获取执行返回结果。

FutureTask实现了Future和Runnable接口。

```java
    /**
    * 通过callable构建一个既是Future又是Runnable的对象
    */
    public FutureTask(Callable<V> callable) {
        if (callable == null)
            throw new NullPointerException();
        this.callable = callable;
        this.state = NEW;       // ensure visibility of callable
    }
    /**
    * 通过runnable构建一个既是Future又是Runnable的对象
    */
    public FutureTask(Runnable runnable, V result) {
        this.callable = Executors.callable(runnable, result);
        this.state = NEW;       // ensure visibility of callable
    }
```

## Executor框架
创建一个线程是有代价，需要和操作系统进行交互，管理一个线程也是需要牺牲额外的性能的。因此一般不显式的创建线程，而是通过线程池来创建管理线程。Executors工具类有许多静态方法来创建线程池。Executor框架主要包括**Executor**接口，**ExecutorService**接口和**Executors**工具类。

![20190724133929.png](https://repositoryimage.oss-cn-shanghai.aliyuncs.com/img/20190724133929.png)

Executor 接口只有一个方法execute,ExecutorService扩展了Executor，添加了操控线程池生命周期的方法，如shutDown()，shutDownNow()等，以及扩展了可异步跟踪执行任务生成返回值Future的方法，如submit()等方法。ThreadPoolExecutor继承自AbstractExecutorService，同时实现了ExecutorService接口，也是Executor框架默认的线程池实现类，一般我们使用线程池，如没有特殊要求，直接创建ThreadPoolExecutor，初始化一个线程池，如果需要特殊的线程池，则直接继承ThreadPoolExecutor，并实现特定的功能，如ScheduledThreadPoolExecutor，它是一个具有定时执行任务的线程池。

> Executor接口： This interface provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use, scheduling, etc.( 此接口提供了一种将任务提交与每个任务的运行机制分离的方法，包括线程使用，调度等的详细信息。)

> ExecutorService接口： 继承自Executor接口，**submit()**方法提交任务之后会返回一个Future对象，同时提供了关闭线程池的方法，**shutDown()**会在关闭线程池之前执行完当前等待队列中的任务，**shutdownNow()**会取消所有任务并关闭线程。**invokeAny()**和**invokeAll()**会阻塞等待任意一个或者所有的任务执行完。

> Executors是Executor,ExecutorService等的工厂方法。

### ThreadPoolExecutor

 * <li> If fewer than corePoolSize threads are running, the Executor
 * always prefers adding a new thread
 * rather than queuing.</li>
 *
 * <li> If corePoolSize or more threads are running, the Executor
 * always prefers queuing a request rather than adding a new
 * thread.</li>
 *
 * <li> If a request cannot be queued, a new thread is created unless
 * this would exceed maximumPoolSize, in which case, the task will be
 * rejected.</li>
 
 当新的任务被提交的时候，首先判断线程池中活跃线程的数目，如果小于corePoolSize，即使其他线程是空闲的，也会新建一个线程去执行该任务；如果大于corePoolSize但是小于maximumPoolSize，线程池优先将任务加入工作队列；如果队列已满，线程数大于maximumPoolSize，线程池会采用相应的拒绝策略拒绝这个任务。

创建一个新的线程池需要的几个核心参数：

- corePoolSize 核心线程池数目
- maximumPoolSize 线程池最大线程数
- keepAliveTime 空闲线程多久会被回收
- unit keepAliveTime的单位
- workQueue 工作队列，用来存放任务
- threadFactory 新建线程的工厂方法
- handler 拒绝任务的策略

接下来开始看线程池的工作流程，在开始之前，需要先知道几个概念：
* ctl 是一个32位的整数，用来存放线程池的状态和当前线程池的线程数，其中高3位用来存放线程池状态，低29位表示线程数。线程池主要有以下状态：RUNNING，SHUTDOWN，STOP，TIDYING,TERMINATED.
    - RUNNING：接受新的任务，处理等待队列中的任务
    - SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务
    - STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程
    - TIDYING：所有的任务都销毁了，workCount 为 0。线程池的状态在转换为TIDYING 状态时，会执行terminated()
    - TERMINATED：terminated() 方法结束后线程池的状态
* 在线程池中使用使用worker来包装线程，每一个工作的线程就是一个worker，线程池通过一个set来保存所有的worker。

接下来就可以开始分析啦。
从execute开始
```java
    public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();\
        // 获取ctl值
        int c = ctl.get();

        // 如果当前活跃线程数目小于corePoolSize
        if (workerCountOf(c) < corePoolSize) {
            // 添加一个worker（线程）来开始工作
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        // 如果线程池处于running状态，将任务加入到工作队列里面
        if (isRunning(c) && workQueue.offer(command)) {
            // 加入之前再检查一次状态
            int recheck = ctl.get();
            // 如果线程池不再是running状态并且移除入队的任务，执行拒绝策略
            if (! isRunning(recheck) && remove(command))
                reject(command);
            // 如果线程池处于running状态但是活跃线程为0，而此时工作队列里
            // 还有刚刚入队的任务，新建worker（线程）来执行刚刚入队的任务
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        // 如果添加新的worker（线程）失败，说明此时已经超过最大线程数，执行
        // 拒绝策略
        else if (!addWorker(command, false))
            reject(command);
    }
```

可以看出，execute方法的核心是addWorker，因此接下来看addWorker方法：

```java
private boolean addWorker(Runnable firstTask, boolean core) {
      ……
        boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = null;
        try {
        // 新建一个worker与任务相关联
            w = new Worker(firstTask);
            final Thread t = w.thread;
            if (t != null) {
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                    int rs = runStateOf(ctl.get());
                    if (rs < SHUTDOWN ||
                        (rs == SHUTDOWN && firstTask == null)) {
                        if (t.isAlive()) // precheck that t is startable
                            throw new IllegalThreadStateException();
                        // 将新增的worker加入线程池的worker队列中
                        workers.add(w);
                        int s = workers.size();
                        if (s > largestPoolSize)
                            largestPoolSize = s;
                        workerAdded = true;
                    }
                } finally {
                    mainLock.unlock();
                }
                if (workerAdded) {
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {
            if (! workerStarted)
                addWorkerFailed(w);
        }
        return workerStarted;
    }
```

加入worker之后
![20190722183643.png](https://repositoryimage.oss-cn-shanghai.aliyuncs.com/img/20190722183643.png)

![20190724143503.png](https://repositoryimage.oss-cn-shanghai.aliyuncs.com/img/20190724143503.png)

tips:

ScheduleExecutorService接口具有预定执行（Scheduled Execution）或者重复执行任务而设计的方法。Executors 类的newScheduledThreadPool 和newSingleThreadScheduledExecutor 方法将返回实现了 ScheduledExecutorService 接口的对象。

## CompletableFuture

### 异步计算
异步调用就是无需等待调用函数的返回结果而可以继续执行操作，异步计算说的是使用另一个线程来完成调用中的计算部分，使调用继续运行或者返回，而不需要等待计算结果。

### 回调函数
通过函数指针调用的函数，吧函数的指针作为参数传递给另一个函数，当这个指针被用为调用它所指向的函数的时候，就说这是会掉函数。回调函数是在特定的事件或者条件发生时由另外一方调用的，用于表示对该事件或者条件进行响应。

定义回调函数 --> 函数实现方初始化后将函数指针传递给调用者 --> 调用者在特定的事件下调用函数

### 与Future的联系
JDK5 新增的Future接口用于描述异步计算的结果，但是对于结果的获取不方便，只能通过阻塞或者轮询的方式得到任务的结果


有结果的同步行为 Callable句柄
无结果的同步行为 Runnable句柄
异步行为         Future句柄
异步回调行为     CompletableFuture句柄


### CompletableFuture的API
- 创建类型：创建CompletableFuture
   1. completedFuture
   2. runAsync
   3. supplyAsync
   4. anyOf
   5. allOf
- 状态相关
   1. join
   2. get
   3. getNow
   4. isCancelled
   5. isCompletedExceptionally
   6. isDone
 - 行为相关
    1. complete
    2. completeExceptionally
    3. cancel
- 回调相关：对计算结果做下一步处理，行为接续
    1. thenApply , thenApplyAsync
    2. thenAccept , thenAcceptAsync
    3. thenRun , thenRunAsync
    4. thenCombine , thenCombineAsync
    5. thenAcceptBoth , thenAcceptBothAsync
    6. runAfterBoth , runAfterBothAsync
    7. applyToEither , applyToEitherAsync
    8. thenCompose , thenComposeAsync
    9. whenComplete , whenCompleteAsync
    10. handle , handleAsync
    11. exceptionally

 规律： 
  * 带Async的是异步方法，不带的则为同步方法
  * 带run的方法，其方法入参的lambda表达式一定是无参数，并且无返回，对应Runnable
  * 带supply的方法，其方法入参的lambda表达式一定是无参数，并且有返回，对应Supplier
  * 带Accept的方法，其方法入参的lambda表达式一定是有参数，并且无返回，对应Consumer
  * 带Apply的方法，其方法入参的lambda表达式一定是有参数，并且有返回，对应Function
  * 

接续即是CompletableFuture存在的核心价值。接续分为以下几种：

CompletableFuture + (Runnable,Consumer,Function)
CompletableFuture + CompletableFuture
CompletableFuture + 结果处理