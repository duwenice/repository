## 编码
在计算机的世界里面只有0和1，其中最小的单位称为bit（位），每一位可能是0或者1，如果使用bit来表示现实世界中的事物，状态太少，因此一般将8bit作为一个整体，称为一个byte（字节）。这样每个字节就有256种状态，可以用来表示具体信息了，比如说ACSII码就是使用一个字节来表示的。通过一张ACSII表，将英文中的26个字母以及符号就都能进行表示了，要是世界上只有英文，那么使用一个字节的ACSII编码就完全可以了，但是比如说汉字，汉字总数应该在十万上下，因此使用一个字节肯定是不行的了，因此就出现了字符的概念，一个字符由一个或者多个字节组成。我国的汉字编码现行标准是GB18030，每个字可以由1个、2个或4个字节组成，编码空间有161万个字符。要是每个国家都采取自己的编码，那么在网络通信的时候，同一段字节流，在美国可能是“hello world”，在中国可能就是“锟斤拷”，“烫烫烫”了。因此在全球范围内采用同一种编码是大势所趋，这就是Unicode的愿景。

既然Unicode定义了全球的字符，那么UTF-16,UTF-8是什么呢？
答案是Unicode只是定义了字符的规则，但是具体的编码解码实现是由UTF-16或者UTF-8来做的。UTF-16是java系统默认的编码，使用两个字节来编码解码；但是在使用的过程中，比如说英文字母如果使用UTF-16的话，那么前面那个字节就会是00的情况，这样在网络传输过程中就会白白浪费很多带宽，于是可变长的UTF-8就出现了。UTF-8是怎么样实现可变长的呢？答案是UTF-8通过增加一些冗余信息来进行判断这个字符是否还需要继续往下读字节。具体来说，如果一个字节以0开头，说明是一个ACSII码，只占一个字节，不需要继续往下读，如果一个字节以11开头，说明还需要继续往下读，后面的每个以10开头的字节都是这个字符的一部分。

## Java中需要编码的场景

### Java 磁盘IO流中的编码
Java处理IO的接口一般分为两类:字节流和字符流。而IO的操作就两种，读和写。读操作的步骤一般是将文本中的数据转换称为字节流，然后将字节流转化称为字符流；写操作则相反。以Java中的磁盘（文件）IO的读操作作为示例：主要涉及以下类:Reader，InputStream，以及两者转化的InputStreamReader。他们的关系如下图所示:
![20190924140218.png](https://repositoryimage.oss-cn-shanghai.aliyuncs.com/img/20190924140218.png)

其中进行编码的核心是StreamDecode类，该类的构造通过阅读源码得到以下结论:如果没有传入Charset(编码),则去获取当前文件的编码，如果没有，默认使用UTF-8；如果传入了Charset，则按照相应的编码构造。
写操作也是类似的，此处就不提了。

### Java 网络IO流中的编码

### Java 内存中的编码
在java中，一个常见的经过内存的IO流程如下:

![20190924103006.png](https://repositoryimage.oss-cn-shanghai.aliyuncs.com/img/20190924103006.png)

在Java内存中，字符对应的数据结构是char（两个字节），但是我们经常用的是String（char的数组）。字节与String之间的转换就涉及到了编码的操作。比如说下面这段代码:
```java
        String str = "I Love China";
        byte[] bytes = str.getBytes("UTF-8");
        String string = new String(bytes, "UTF-8");
```

